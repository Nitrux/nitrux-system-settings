#!/usr/bin/env bash

# SPDX-License-Identifier: BSD-3-Clause
# Copyright 2024-2025 <Nitrux Latinoamericana S.C. <hello@nxos.org>>


# -- Variables.

umask 077

CRITICAL_LEVEL=${CRITICAL_LEVEL:-20}
BALANCED_MIN=${BALANCED_MIN:-21}
BALANCED_MAX=${BALANCED_MAX:-59}
PERF_ON_BATT_MIN=${PERF_ON_BATT_MIN:-60}

STATE_DIR="${XDG_STATE_HOME:-$HOME/.local/state}/nx-dynamic-ppd"
LOG_FILE="$STATE_DIR/nx-dynamic-ppd.log"
LOCK_FILE="${XDG_RUNTIME_DIR:-$STATE_DIR}/nx-dynamic-ppd.lock"

mkdir -p "$STATE_DIR"
mkdir -p "$(dirname "$LOCK_FILE")"

log() {
    printf '%s\n' "$(date -Is) $*"
}

if [ "${DEBUG:-0}" != "1" ]; then
    exec >>"$LOG_FILE" 2>&1
fi

log "start pid=$$"

acquire_lock() {
    if command -v flock >/dev/null 2>&1; then
        exec 9>"$LOCK_FILE"
        if ! flock -n 9; then
            if [ "${DEBUG:-0}" = "1" ]; then
                log "lock held; DEBUG=1 so continuing without lock"
                exec 9>&-
                return 0
            fi
            log "exit: lock held ($LOCK_FILE)"
            exit 0
        fi
        return 0
    fi

    if [ -e "$LOCK_FILE" ] && kill -0 "$(cat "$LOCK_FILE" 2>/dev/null)" 2>/dev/null; then
        if [ "${DEBUG:-0}" = "1" ]; then
            log "lock held; DEBUG=1 so continuing without lock"
            return 0
        fi
        log "exit: lock held ($LOCK_FILE)"
        exit 0
    fi

    echo "$$" >"$LOCK_FILE"
    trap 'rm -f "$LOCK_FILE"' EXIT
}


# -- Functions.

has_battery() {
    if [ -z "${BAT_PATH:-}" ]; then
        BAT_PATH=$(find /sys/class/power_supply/ -maxdepth 1 -name "BAT*" 2>/dev/null | head -n 1 || true)
    fi
    [ -n "${BAT_PATH:-}" ] && [ -r "$BAT_PATH/capacity" ]
}

get_battery_capacity() {
    if has_battery; then
        cat "$BAT_PATH/capacity"
    else
        printf '%s\n' -1
    fi
}

get_display_device() {
    upower -e 2>/dev/null | awk '/DisplayDevice/{print; exit}'
}

get_on_battery() {
    local dev s
    dev="$(get_display_device)"
    [ -n "$dev" ] || { printf '%s\n' unknown; return 0; }
    s="$(upower -i "$dev" 2>/dev/null | awk -F': *' '/on-battery:/ {print $2; exit}' | tr -d '\r')"
    case "$s" in
        yes|no) printf '%s\n' "$s" ;;
        *) printf '%s\n' unknown ;;
    esac
}

set_profile_if_needed() {
    local target="$1" urgency="$2" icon="$3" body="$4"
    local current
    current=$(powerprofilesctl get 2>/dev/null || true)
    if [ "$current" != "$target" ]; then
        powerprofilesctl set "$target"
        if command -v notify-send >/dev/null 2>&1; then
            notify-send -a "System Message" -t 5000 -u "$urgency" -i "$icon" "Power Profile" "$body"
        fi
        log "profile: $current -> $target ($body)"
    else
        log "profile: unchanged ($current) ($body)"
    fi
}

apply_policy_for_state() {
    local state="$1" cap

    if ! has_battery; then
        log "state=$state bat=0"
        if [ "$state" = "ac" ]; then
            set_profile_if_needed "performance" "low" "ac-adapter" "AC detected (no battery): performance"
        fi
        return 0
    fi

    cap="$(get_battery_capacity)"
    log "state=$state bat=1 cap=$cap"

    if [ "$state" = "ac" ]; then
        set_profile_if_needed "performance" "low" "ac-adapter" "AC detected: performance"
        return 0
    fi

    if [ "$cap" -lt 0 ]; then
        return 0
    fi

    if [ "$cap" -ge "$PERF_ON_BATT_MIN" ]; then
        set_profile_if_needed "performance" "low" "battery-100" "On battery (${cap}%): performance"
    elif [ "$cap" -ge "$BALANCED_MIN" ] && [ "$cap" -le "$BALANCED_MAX" ]; then
        set_profile_if_needed "balanced" "low" "battery-060" "On battery (${cap}%): balanced"
    elif [ "$cap" -le "$CRITICAL_LEVEL" ]; then
        set_profile_if_needed "power-saver" "critical" "battery-low" "On battery (${cap}%): power-saver"
    else
        set_profile_if_needed "balanced" "low" "battery-060" "On battery (${cap}%): balanced"
    fi
}

wait_for_state() {
    local tries=20 s
    while :; do
        s="$(get_on_battery)"
        case "$s" in
            yes) printf '%s\n' battery; return 0 ;;
            no)  printf '%s\n' ac; return 0 ;;
        esac
        tries=$((tries-1))
        [ "$tries" -le 0 ] && { printf '%s\n' battery; return 0; }
        sleep 0.2
    done
}


# -- Monitor the power supply status change and apply the adequate power profile.

state="$(wait_for_state)"
apply_policy_for_state "$state" || true

if has_battery; then
    upower --monitor-detail 2>/dev/null | while IFS= read -r line; do
        case "$line" in
            *"on-battery:"*"yes"*) new="battery" ;;
            *"on-battery:"*"no"*)  new="ac" ;;
            *"percentage:"*)
                [ "$state" = "battery" ] && apply_policy_for_state "$state" || true
                continue
                ;;
            *) continue ;;
        esac
        [ "$new" = "$state" ] && continue
        state="$new"
        apply_policy_for_state "$state" || true
    done
else
    while :; do
        sleep 3600
    done
fi
